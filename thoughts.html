<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Thoughts</title>
  <link rel="stylesheet" href="style.css">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0"></script>
</head>
<body>
  <div class="layout">
    <main class="content" id="content"></main>
    <nav id="nav"></nav>
  </div>
  <script src="config.js"></script>
  <script>
    const name = CONFIG.name;
    let allContent = [];
    let fuse = null;
    
    // Convert [[wikilinks]] to actual links
    function parseWikiLinks(md) {
      return md.replace(/\[\[([^\]]+)\]\]/g, (match, link) => {
        return `[${link}](#${link.toLowerCase()})`;
      });
    }
    
    // Generate ID from text
    function generateId(text) {
      return 't-' + text.toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-|-$/g, '')
        .slice(0, 30);
    }
    
    // Load all content for search
    async function loadAllContent(categories) {
      allContent = [];
      for (const cat of categories) {
        try {
          const res = await fetch(`content/thoughts/${cat}.md`);
          if (res.ok) {
            const md = await res.text();
            
            // Also index the full category content for broad searches
            const fullText = md
              .replace(/\*\*/g, '')
              .replace(/\[\[([^\]]+)\]\]/g, '$1')
              .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
              .replace(/^- /gm, '')
              .replace(/\n+/g, ' ')
              .trim();
            
            allContent.push({
              category: cat,
              text: fullText,
              preview: cat.charAt(0).toUpperCase() + cat.slice(1) + ' (full)',
              id: '',
              isCategory: true
            });
            
            // Index individual thoughts
            const lines = md.split('\n');
            for (const line of lines) {
              const match = line.match(/^(\s*)- (.+)/);
              if (match) {
                const text = match[2]
                  .replace(/\*\*/g, '')
                  .replace(/\[\[([^\]]+)\]\]/g, '$1')
                  .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
                  .trim();
                
                if (text.length > 0) {
                  const id = generateId(text);
                  allContent.push({ 
                    category: cat, 
                    text: text,
                    preview: text.slice(0, 100),
                    id: id,
                    isCategory: false
                  });
                }
              }
            }
          }
        } catch (e) {}
      }
      fuse = new Fuse(allContent, {
        keys: ['text'],
        threshold: 0.6,
        ignoreLocation: true,
        minMatchCharLength: 1,
        findAllMatches: true,
        distance: 1000
      });
    }
    
    // Find backlinks
    async function findBacklinks(categories, currentCategory) {
      const backlinks = [];
      for (const cat of categories) {
        if (cat === currentCategory) continue;
        try {
          const res = await fetch(`content/thoughts/${cat}.md`);
          if (res.ok) {
            const md = await res.text();
            if (md.toLowerCase().includes(`[[${currentCategory}]]`)) {
              backlinks.push(cat);
            }
          }
        } catch (e) {}
      }
      return backlinks;
    }
    
    function renderSearch() {
      return `
        <div class="search-container">
          <input type="text" id="search" placeholder="Search thoughts..." />
          <div id="search-results"></div>
        </div>
      `;
    }
    
    function setupSearch() {
      const input = document.getElementById('search');
      const results = document.getElementById('search-results');
      
      input.addEventListener('input', (e) => {
        const query = e.target.value.trim();
        if (query.length < 2) {
          results.innerHTML = '';
          return;
        }
        
        const matches = fuse.search(query).slice(0, 8);
        if (matches.length === 0) {
          results.innerHTML = '<div class="search-item no-results">No results found</div>';
          return;
        }
        
        results.innerHTML = matches.map(m => {
          const href = m.item.id ? `#${m.item.category}:${m.item.id}` : `#${m.item.category}`;
          return `<a href="${href}" class="search-item">
            <span class="search-cat">${m.item.category}</span>
            ${m.item.preview}
          </a>`;
        }).join('');
      });
    }
    
    function addIdsToHtml(html) {
      const div = document.createElement('div');
      div.innerHTML = html;
      
      div.querySelectorAll('li').forEach(li => {
        const text = li.childNodes[0]?.textContent?.trim() || '';
        if (text) {
          li.id = generateId(text);
        }
      });
      
      return div.innerHTML;
    }
    
    function scrollToThought(id) {
      const el = document.getElementById(id);
      if (el) {
        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        el.classList.add('highlight');
        setTimeout(() => el.classList.remove('highlight'), 2000);
      }
    }
    
    document.addEventListener("DOMContentLoaded", async () => {
      const hash = window.location.hash.slice(1);
      const [category, scrollToId] = hash.split(':');
      const nav = document.getElementById("nav");
      
      // Load categories
      let categories = [];
      try {
        const res = await fetch("content/thoughts/_index.md");
        if (res.ok) {
          const text = await res.text();
          categories = text.trim().split("\n").filter(c => c.trim());
        }
      } catch (e) {}
      
      // Load search index
      await loadAllContent(categories);
      
      // Build nav
      nav.innerHTML = `
        <a href="index.html" class="name">${name}</a>
        ${categories.map(c => 
          `<a href="#${c}" class="${c === category ? 'active' : ''}">${c.charAt(0).toUpperCase() + c.slice(1)}</a>`
        ).join("")}
      `;
      
      if (category) {
        try {
          const res = await fetch(`content/thoughts/${category}.md`);
          if (res.ok) {
            let md = await res.text();
            md = parseWikiLinks(md);
            let html = marked.parse(md);
            html = html.replace(/<ul>/g, '<ul class="thread">');
            html = addIdsToHtml(html);
            
            const backlinks = await findBacklinks(categories, category);
            if (backlinks.length > 0) {
              html += `<div class="backlinks"><strong>Linked from:</strong> ${backlinks.map(b => 
                `<a href="#${b}">${b.charAt(0).toUpperCase() + b.slice(1)}</a>`
              ).join(" · ")}</div>`;
            }
            
            document.getElementById("content").innerHTML = renderSearch() + html;
            setupSearch();
            
            if (scrollToId) {
              setTimeout(() => scrollToThought(scrollToId), 150);
            }
          }
        } catch (e) {}
      } else {
        document.getElementById("content").innerHTML = renderSearch() + "<p>Select a category →</p>";
        setupSearch();
      }
    });
    
    window.addEventListener("hashchange", () => location.reload());
  </script>
</body>
</html>
